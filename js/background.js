// js/background.js - Service Worker with Google Drive backup support and PDF functionality
// This script is the central nervous system of the WebInsight Chrome extension.
// It runs in the background, managing tasks such as:
// - Handling user interactions from the context menu and browser action (toolbar icon).
// - Saving various types of content (full pages, text selections, screenshots, PDFs).
// - Interacting with the IndexedDB database for storing and retrieving saved content and tags.
// - Communicating with content scripts injected into web pages.
// - Managing AI-powered analysis of content (e.g., image analysis, text summarization).
// - Scheduling and performing auto-backups (currently placeholder for Google Drive).
// - Generating PDF reports from tagged content.
// - Managing local AI functionalities like tag suggestions and embeddings.

// --- Imports ---
import { initDB, addContentItem, getAllContentItems, updateContentItem, deleteContentItem, addTag, getTagByName, getAllTags, deleteTag, linkTagToContent, unlinkTagFromContent, getTagIdsByContentId, getContentIdsByTagId, getTagsByIds, getContentItemsByIds, getAllContentTags } from './lib/db.js';
import { analyzeImageWithGemini, analyzeTextWithGemini, getApiKey } from './lib/api.js';
import { generatePagePDF, pdfToDataUrl, estimatePDFSize, PDFPresets } from './lib/pdf-generator.js';
import { localAI } from './lib/local-ai.js'; // This is currently the keyword-based AI

// --- Constants ---
const MAX_ITEMS_FOR_SUMMARY = 5; // Maximum number of items to use when generating a summary for key points.
const GENERATED_ITEM_TYPE = "generated_analysis"; // Type identifier for content items that are generated by AI (e.g., key points).

// --- Service Worker Lifecycle & Setup ---

/**
 * Listener for the extension's installation or update.
 * Sets up initial configurations like context menus, database, and default settings.
 * @param {object} details - Object containing details about the installation or update.
 *                           Includes `reason` (e.g., "install", "update") and `previousVersion`.
 */
chrome.runtime.onInstalled.addListener(async (details) => {
    console.log(`WebInsight extension ${details.reason}. Previous version: ${details.previousVersion}`);
    try {
        await setupContextMenu(); // Initialize or update context menu items.
        await initDB(); // Initialize the IndexedDB database.
        if (details.reason === 'install') {
            // Set default theme to 'system' on fresh install.
            chrome.storage.sync.set({ theme: 'system' }, () => {
                 if (chrome.runtime.lastError) console.error("Error setting default theme:", chrome.runtime.lastError);
                 else console.log("Default theme setting applied.");
            });
            // Set default auto-backup to 'disabled' on fresh install.
            chrome.storage.local.set({ autoBackup: 'disabled' }, () => {
                if (chrome.runtime.lastError) console.error("Error setting default auto-backup:", chrome.runtime.lastError);
                else console.log("Default auto-backup setting applied.");
            });
        }
    } catch (error) {
        console.error("Error during onInstalled setup:", error);
    }
});

// --- Auto-backup scheduling ---

/**
 * Listener for Chrome alarms. Used here to trigger scheduled auto-backups.
 * @param {chrome.alarms.Alarm} alarm - The alarm object that fired.
 */
chrome.alarms.onAlarm.addListener(async (alarm) => {
    if (alarm.name === 'webinsight-auto-backup') {
        console.log("Auto-backup alarm triggered");
        await performAutoBackup(); // Execute the auto-backup procedure.
    }
});

// --- Toolbar Action (Icon Click) Listener ---

/**
 * Listener for when the extension's toolbar icon (browser action) is clicked.
 * Opens the side panel for the current window.
 * @param {chrome.tabs.Tab} tab - The tab where the icon was clicked.
 */
chrome.action.onClicked.addListener(async (tab) => {
    console.log("Extension icon clicked on tab:", tab.id);
    let windowIdToUse = tab.windowId;
    // Fallback if tab.windowId is not available (e.g., some special pages).
    if (!windowIdToUse) {
        console.warn("Action clicked on tab without windowId, querying current window.");
        try {
            const currentWindow = await chrome.windows.getCurrent({ populate: false });
            if (currentWindow && currentWindow.id) windowIdToUse = currentWindow.id;
            else { console.error("Cannot determine window ID to open side panel."); return; }
        } catch (error) { console.error("Error getting current window:", error); return; }
    }
    try {
        // Request to open the side panel in the determined window.
        await chrome.sidePanel.open({ windowId: windowIdToUse });
        console.log("Side panel open request sent for window:", windowIdToUse);
    } catch (error) {
        console.error("Error opening side panel:", error);
    }
});

// --- Context Menu Setup ---

/**
 * Sets up or updates the context menu items for the extension.
 * This includes options to save selected text and save the current page as a PDF.
 * Uses `chrome.contextMenus.update` with a callback to check `chrome.runtime.lastError`.
 * If `lastError` is set, it means the menu item doesn't exist, so it creates it.
 * Otherwise, it assumes the update was successful (or the item already existed with the same properties).
 * @async
 */
async function setupContextMenu() {
    // Context menu for saving selected text.
    chrome.contextMenus.update("saveSelectionWebInsight", {
         title: "Save selected text to WebInsight", contexts: ["selection"]
     }, () => {
         if (chrome.runtime.lastError) {
             console.log("Context menu item 'saveSelectionWebInsight' not found, creating it.");
             chrome.contextMenus.create({ id: "saveSelectionWebInsight", title: "Save selected text to WebInsight", contexts: ["selection"] });
         } else { console.log("Context menu item 'saveSelectionWebInsight' updated/verified successfully."); }
     });

    // Context menu for saving the current page as a PDF.
    chrome.contextMenus.update("savePageAsPDFWebInsight", {
         title: "Save page as PDF to WebInsight", contexts: ["page"]
     }, () => {
         if (chrome.runtime.lastError) {
             console.log("Context menu item 'savePageAsPDFWebInsight' not found, creating it.");
             chrome.contextMenus.create({ 
                id: "savePageAsPDFWebInsight", 
                title: "Save page as PDF to WebInsight", 
                contexts: ["page"] 
            });
         } else { 
            console.log("Context menu item 'savePageAsPDFWebInsight' updated/verified successfully."); 
        }
     });
}

/**
 * Listener for clicks on context menu items created by this extension.
 * @param {chrome.contextMenus.OnClickData} info - Information about the clicked menu item.
 * @param {chrome.tabs.Tab} tab - The tab where the click occurred.
 * @async
 */
chrome.contextMenus.onClicked.addListener(async (info, tab) => {
    if (info.menuItemId === "saveSelectionWebInsight") {
        // Handle saving selected text.
        if (info.selectionText && tab) {
             console.log("Context menu save triggered for:", info.selectionText.substring(0, 50) + '...');
             saveContent({
                 type: 'selection',
                 content: info.selectionText,
                 url: tab.url || info.pageUrl, // Use tab.url if available, otherwise pageUrl from context.
                 title: `Selection from: ${tab.title || 'Untitled Page'}`
             }).then(id => console.log(`Context menu selection saved with ID: ${id}`))
               .catch(error => console.error("Error saving selection from context menu:", error));
        } else { console.warn("Context menu clicked, but no selection text or tab info found.", info); }
    } else if (info.menuItemId === "savePageAsPDFWebInsight") {
        // Handle saving the page as a PDF.
        if (tab && tab.id) {
            console.log("Context menu PDF save triggered for:", tab.title || tab.url);
            handleSavePageAsPDF({ preset: 'standard' }) // Use 'standard' PDF preset.
                .then(id => console.log(`Context menu PDF saved with ID: ${id}`))
                .catch(error => console.error("Error saving PDF from context menu:", error));
        } else {
            console.warn("Context menu PDF clicked, but no valid tab found.", info);
        }
    }
});

// --- Storage change listener for auto-backup settings ---

/**
 * Listener for changes in `chrome.storage.local`.
 * Specifically monitors changes to the 'autoBackup' setting to update the alarm schedule.
 * @param {object} changes - Object mapping changed keys to their `storage.StorageChange` objects.
 * @param {string} namespace - The storage area ('sync' or 'local') where the change occurred.
 */
chrome.storage.onChanged.addListener((changes, namespace) => {
    if (namespace === 'local' && changes.autoBackup) {
        console.log("Auto-backup setting changed:", changes.autoBackup);
        updateAutoBackupSchedule(changes.autoBackup.newValue); // Update alarm based on new setting.
    }
});

// --- Message Listener ---

/**
 * Main message listener for the service worker. Handles various requests from other parts of the extension
 * (e.g., content scripts, side panel, options page).
 * Uses a switch statement to route messages to appropriate handler functions.
 * @param {object} message - The message object sent. Should have a `type` property.
 * @param {chrome.runtime.MessageSender} sender - Object containing information about the sender.
 * @param {function} sendResponse - Function to call to send a response back to the sender.
 *                                  Return `true` from the listener to indicate an asynchronous response.
 * @returns {boolean} - Returns `true` if `sendResponse` will be called asynchronously, `false` otherwise.
 */
chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
    const senderType = sender.tab ? `Content Script (Tab ${sender.tab.id})` : "Extension UI (Panel/Options/Viewer)";
    console.log("Message received in background:", message, "From:", senderType);
    let isResponseAsync = true; // Flag to indicate if sendResponse will be called asynchronously.

    // Route incoming messages based on their 'type' property to the appropriate handler.
    // Most handlers are asynchronous and will use sendResponse to reply.
    // If a handler is synchronous or an early error occurs, isResponseAsync is set to false.
    switch (message.type) {
        // --- Content Saving ---
        case "SAVE_PAGE_CONTENT":
            // Handles request from UI to save the entire current page's content (text and HTML).
            handleSavePageContent()
                .then(id => sendResponse({ success: true, id: id }))
                .catch(error => sendResponse({ success: false, error: error.message }));
            break;
        case "SAVE_SELECTION":
            // Handles request from UI to save the currently selected text on the page.
            handleSaveSelection()
                .then(id => sendResponse({ success: true, id: id }))
                .catch(error => sendResponse({ success: false, error: error.message }));
            break;
        case "SAVE_PAGE_AS_PDF":
            // Handles request from UI to save the current page as a PDF document.
            // `message.payload` can contain PDF generation options (e.g., preset name).
            handleSavePageAsPDF(message.payload)
                .then(id => sendResponse({ success: true, id: id }))
                .catch(error => sendResponse({ success: false, error: error.message }));
            break;

        // --- Screenshot Capturing ---
        case "CAPTURE_VISIBLE_TAB":
            // Handles request from UI to capture the currently visible part of the active tab.
            handleCaptureVisibleTab()
                .then(id => sendResponse({ success: true, id: id }))
                .catch(error => sendResponse({ success: false, error: error.message }));
            break;
        case "INITIATE_AREA_CAPTURE":
            // Sends a message to the content script of the active tab to start the area selection UI for a screenshot.
            handleInitiateAreaCapture()
                .then(response => sendResponse(response)) // Response from content script
                .catch(error => sendResponse({ success: false, error: error.message }));
            break;
        case "CAPTURE_AREA_FROM_CONTENT":
            // Receives coordinates and other details (rect, devicePixelRatio, url, title)
            // from the content script after user selects an area, then captures and saves that area.
            if (!sender.tab) { // Requires sender.tab to identify the target tab for capture.
                sendResponse({ success: false, error: "Missing sender tab info for area capture." });
                isResponseAsync = false; // Synchronous response for this validation error.
            } else {
                handleCaptureArea(message.payload, sender.tab)
                    .then(id => sendResponse({ success: true, id: id }))
                    .catch(error => { console.error("Error during handleCaptureArea in background:", error); sendResponse({ success: false, error: error.message }); });
            }
            break;

        // --- Data Retrieval / Deletion ---
        case "GET_ALL_SAVED_CONTENT":
            // Handles request from UI to retrieve all saved content items from the database.
            getAllContentItems()
                .then(items => sendResponse({ success: true, payload: items }))
                .catch(error => { console.error("Error getting all content items:", error); sendResponse({ success: false, error: `Failed retrieve items: ${error.message}` }); });
            break;
        case "DELETE_ITEM":
            // Handles request from UI to delete a specific content item by its ID.
            // Payload: { id: number }
            const itemIdToDelete = message.payload?.id;
            if (typeof itemIdToDelete !== 'number') {
                sendResponse({ success: false, error: "Invalid item ID for deletion." });
                isResponseAsync = false;
            } else {
                deleteContentItem(itemIdToDelete)
                    .then(() => {
                        // Update timestamp to trigger UI refreshes in other parts of the extension.
                        chrome.storage.local.set({ lastSaveTimestamp: Date.now() }, () => { if (chrome.runtime.lastError) console.error("Error setting timestamp on delete item:", chrome.runtime.lastError); });
                        sendResponse({ success: true });
                    })
                    .catch(error => { console.error(`Error deleting item ID ${itemIdToDelete}:`, error); sendResponse({ success: false, error: `Failed delete item: ${error.message}` }); });
            }
            break;

        // --- Tag Fetching ---
        case "GET_TAGS_FOR_ITEM":
            // Handles request from UI to retrieve all tags associated with a specific content item.
            // Payload: { contentId: number }
            const contentIdForTags = message.payload?.contentId;
            if (typeof contentIdForTags !== 'number') {
                sendResponse({ success: false, error: "Invalid contentId for fetching tags." });
                isResponseAsync = false;
            } else {
                getTagIdsByContentId(contentIdForTags) // Fetches IDs of tags linked to the content item.
                    .then(tagIds => tagIds && tagIds.length > 0 ? getTagsByIds(tagIds) : []) // If tag IDs exist, fetches the full tag objects.
                    .then(tags => sendResponse({ success: true, payload: tags }))
                    .catch(error => { console.error(`Error fetching tags for content item ID ${contentIdForTags}:`, error); sendResponse({ success: false, error: `Failed fetch tags: ${error.message}` }); });
            }
            break;

        // --- Tag Management ---
        case "ADD_TAG_TO_ITEM":
            // Handles request from UI to add a new or existing tag to a content item.
            // Payload: { contentId: number, tagName: string }
            const { contentId: addContentId, tagName: addTagName } = message.payload || {};
            if (typeof addContentId !== 'number' || !addTagName || typeof addTagName !== 'string' || addTagName.trim().length === 0) {
                sendResponse({ success: false, error: "Invalid contentId or tagName for adding tag." });
                isResponseAsync = false;
            } else {
                const trimmedTagName = addTagName.trim();
                addTag(trimmedTagName) // Adds the tag to the 'tags' table (or retrieves it if already exists).
                    .then(tagId => {
                        if (typeof tagId !== 'number') throw new Error("Invalid tag ID returned after addTag.");
                        return linkTagToContent(addContentId, tagId); // Creates the link in the 'content_tags' join table.
                    })
                    .then(() => {
                        chrome.storage.local.set({ lastSaveTimestamp: Date.now() }, () => { if (chrome.runtime.lastError) console.error("Error setting timestamp after adding tag to item:", chrome.runtime.lastError); });
                        sendResponse({ success: true });
                    })
                    .catch(error => { console.error(`Error adding tag "${trimmedTagName}" to item ID ${addContentId}:`, error); sendResponse({ success: false, error: `Failed add tag: ${error.message}` }); });
            }
            break;
        case "REMOVE_TAG_FROM_ITEM":
            // Handles request from UI to remove a tag from a content item.
            // Payload: { contentId: number, tagId: number }
            const { contentId: removeContentId, tagId: removeTagId } = message.payload || {};
            if (typeof removeContentId !== 'number' || typeof removeTagId !== 'number') {
                sendResponse({ success: false, error: "Invalid contentId or tagId for removing tag." });
                isResponseAsync = false;
            } else {
                unlinkTagFromContent(removeContentId, removeTagId) // Removes the link from 'content_tags' table.
                    .then(() => {
                        chrome.storage.local.set({ lastSaveTimestamp: Date.now() }, () => { if (chrome.runtime.lastError) console.error("Error setting timestamp after removing tag from item:", chrome.runtime.lastError); });
                        sendResponse({ success: true });
                    })
                    .catch(error => { console.error(`Error removing tag ID ${removeTagId} from item ID ${removeContentId}:`, error); sendResponse({ success: false, error: `Failed remove tag: ${error.message}` }); });
            }
            break;

        // --- Tag Filtering / Data Viewer Handlers (typically for the data management/viewer page) ---
        case "GET_ALL_TAGS":
            // Handles request to retrieve all unique tags from the database.
            getAllTags()
                .then(tags => sendResponse({ success: true, payload: tags }))
                .catch(error => { console.error("Error getting all tags:", error); sendResponse({ success: false, error: `Failed to get tags: ${error.message}` }); });
            break;
        case "GET_FILTERED_ITEMS_BY_TAG":
            // Handles request to retrieve all content items associated with a specific tag ID.
            // Payload: { tagId: number }
            const filterTagId = message.payload?.tagId;
            if (typeof filterTagId !== 'number') {
                sendResponse({ success: false, error: "Invalid tagId for filtering items." });
                isResponseAsync = false;
            } else {
                getContentIdsByTagId(filterTagId) // Gets all content IDs linked to this tag.
                    .then(contentIds => contentIds && contentIds.length > 0 ? getContentItemsByIds(contentIds) : []) // Fetches the full content items for those IDs.
                    .then(items => sendResponse({ success: true, payload: items }))
                    .catch(error => { console.error(`Error filtering items by tag ID ${filterTagId}:`, error); sendResponse({ success: false, error: `Failed filter items: ${error.message}` }); });
            }
            break;
        case "GET_ALL_CONTENT_TAGS":
            // Handles request to retrieve all links between content items and tags (the entire 'content_tags' join table).
            // Useful for UIs that need to display all tag relationships.
            getAllContentTags()
                .then(links => sendResponse({ success: true, payload: links }))
                .catch(error => { console.error("Error getting all content_tag links:", error); sendResponse({ success: false, error: `Failed to get content_tag links: ${error.message}` }); });
            break;

        // --- Key Points Generation Handler ---
        case "GET_KEY_POINTS_FOR_TAG":
            // Handles request from UI to generate or retrieve key points for a given tag ID.
            // Payload: { tagId: number }
            const keyPointsTagId = message.payload?.tagId;
            if (typeof keyPointsTagId !== 'number') {
                sendResponse({ success: false, error: "Invalid tagId provided for key points generation." });
                isResponseAsync = false;
            } else {
                handleGetKeyPoints(keyPointsTagId)
                    .then(result => {
                        sendResponse(result); // Result includes success status, newId, sourceInfo, and keyPoints.
                    })
                    .catch(error => {
                        console.error(`Critical error in GET_KEY_POINTS_FOR_TAG for tag ID ${keyPointsTagId}:`, error);
                        sendResponse({ success: false, error: `Failed to generate or save key points: ${error.message}` });
                    });
            }
            break;

        // --- PDF Report Generation Handler ---
        case "GENERATE_PDF_REPORT_FOR_TAG":
            // Handles request from UI to generate a PDF report for all items associated with a specific tag ID.
            // Payload: { tagId: number }
            const reportTagId = message.payload?.tagId;
            if (typeof reportTagId !== 'number') { 
                sendResponse({ success: false, error: "Invalid tagId provided for PDF report generation." }); 
                isResponseAsync = false; 
            } else {
                handleGeneratePDFReport(reportTagId)
                    .then(result => {
                        sendResponse(result); // Result includes success status and filename or an error message.
                    })
                    .catch(error => {
                        console.error(`Critical error in GENERATE_PDF_REPORT_FOR_TAG for tag ID ${reportTagId}:`, error);
                        sendResponse({ success: false, error: `Failed to generate PDF report: ${error.message}` });
                    });
            }
            break;

        // --- Local AI Feature Handlers ---
        case "INITIALIZE_LOCAL_AI":
            // Handles request from UI to initialize the local AI model (e.g., Universal Sentence Encoder).
            handleInitializeLocalAI()
                .then(result => sendResponse(result)) // Result includes success status and a message.
                .catch(error => sendResponse({ success: false, error: error.message }));
            break;
        case "SUGGEST_TAGS_FOR_CONTENT":
            // Handles request from UI to suggest relevant tags for a given piece of text content using local AI.
            // Payload: { content: string }
            const suggestContent = message.payload?.content;
            if (!suggestContent || typeof suggestContent !== 'string') {
                sendResponse({ success: false, error: "Invalid content provided for tag suggestions." });
                isResponseAsync = false;
            } else {
                handleSuggestTags(suggestContent)
                    .then(result => sendResponse(result)) // Result includes success, payload (suggestions), and message.
                    .catch(error => sendResponse({ success: false, error: error.message }));
            }
            break;
        case "GENERATE_EMBEDDINGS_FOR_TAGS":
            // Handles request from UI to generate and store embeddings for all existing tags (if not already present).
            handleGenerateTagEmbeddings()
                .then(result => sendResponse(result)) // Result includes success, payload (counts), and message.
                .catch(error => sendResponse({ success: false, error: error.message }));
            break;
        case "GET_LOCAL_AI_STATUS":
            // Handles request from UI to retrieve the current status of the local AI model (e.g., if it's ready, memory info).
            sendResponse({ 
                success: true, 
                payload: {
                    isReady: localAI.isReady(), // localAI is an imported module.
                    memoryInfo: localAI.getMemoryInfo()
                }
            });
            isResponseAsync = false; // This is a synchronous response.
            break;

        // --- Default ---
        default:
            // Handles any unrecognised message types received by the listener.
            console.warn("Unhandled message type received in background script:", message.type);
            // sendResponse({ success: false, error: `Unknown message type: ${message.type}` }); // Optionally send error back
            isResponseAsync = false; // No asynchronous response for unhandled types.
            break;
    }
    return isResponseAsync; // Must return true if sendResponse is to be called asynchronously.
});

// --- Auto-backup Functions ---

/**
 * Updates or clears the auto-backup alarm based on the provided setting.
 * @param {string} setting - The auto-backup frequency ('disabled', 'daily', 'weekly', 'monthly').
 * @async
 */
async function updateAutoBackupSchedule(setting) {
    try {
        // Clear any existing alarm for auto-backup.
        await chrome.alarms.clear('webinsight-auto-backup');
        
        if (setting === 'disabled') {
            console.log("Auto-backup disabled");
            return; // No new alarm needed if disabled.
        }
        
        let periodInMinutes;
        switch (setting) {
            case 'daily':
                periodInMinutes = 24 * 60; // 1 day
                break;
            case 'weekly':
                periodInMinutes = 7 * 24 * 60; // 7 days
                break;
            case 'monthly':
                periodInMinutes = 30 * 24 * 60; // 30 days (approx)
                break;
            default:
                console.warn("Unknown auto-backup setting:", setting);
                return; // Do not set an alarm for unknown settings.
        }
        
        // Create a new alarm with the specified period.
        // `delayInMinutes` starts the first alarm after this period.
        // `periodInMinutes` sets the interval for subsequent alarms.
        await chrome.alarms.create('webinsight-auto-backup', {
            delayInMinutes: periodInMinutes,
            periodInMinutes: periodInMinutes
        });
        
        console.log(`Auto-backup scheduled: ${setting} (every ${periodInMinutes} minutes)`);
    } catch (error) {
        console.error("Failed to update auto-backup schedule:", error);
    }
}

/**
 * Performs the auto-backup procedure.
 * Currently, this function checks for Google Drive configuration and logs data counts.
 * Actual data export to Google Drive is a placeholder.
 * @async
 */
async function performAutoBackup() {
    try {
        console.log("Performing auto-backup...");
        
        // Check if Google Drive client ID is configured (placeholder for actual Drive integration).
        const settings = await new Promise(resolve => {
            chrome.storage.local.get(['googleClientId'], resolve);
        });
        
        if (!settings.googleClientId) {
            console.log("Auto-backup skipped: Google Drive not configured");
            return;
        }
        
        // Get all data to be backed up.
        const [contentItems, tags, contentTags] = await Promise.all([
            getAllContentItems(),
            getAllTags(),
            getAllContentTags()
        ]);
        
        // Placeholder: In a real implementation, this is where Google Drive authentication
        // and data export would occur.
        console.log("Auto-backup completed (simulated):", {
            contentItems: contentItems.length,
            tags: tags.length,
            contentTags: contentTags.length
        });
        
    } catch (error) {
        console.error("Auto-backup failed:", error);
    }
}

// --- Utility Functions ---

/**
 * Gets the currently active tab in the current window.
 * Ensures the tab has a valid ID and a URL that the extension can access (http, https, file).
 * @returns {Promise<chrome.tabs.Tab>} A promise that resolves with the active tab object.
 * @throws {Error} If no active tab is found or if the tab is inaccessible.
 * @async
 */
async function getCurrentTab() {
    try {
        const tabs = await chrome.tabs.query({ active: true, currentWindow: true });
        if (tabs && tabs.length > 0 && tabs[0]) {
            const tab = tabs[0];
            // Check for valid tab ID and accessible URL scheme.
            if (tab.id !== undefined && tab.id !== chrome.tabs.TAB_ID_NONE) {
                if (tab.url && (tab.url.startsWith('http:') || tab.url.startsWith('https:') || tab.url.startsWith('file:'))) {
                    return tab;
                } else { throw new Error(`Active tab has inaccessible URL (${tab.url}).`); }
            } else { throw new Error(`Active tab has invalid ID (${tab.id}).`); }
        } else { throw new Error("Could not find active tab."); }
    } catch (error) {
        // Log the error and re-throw a more specific error for the caller.
        console.error("Error querying active tab:", error);
        throw new Error(`Failed get active tab: ${error.message}`);
    }
}

// --- Specific Action Handler Functions ---

/**
 * Handles saving the full content (text and HTML) of the current page.
 * This function is typically triggered by a user action (e.g., clicking a "Save Page" button in the UI).
 * It injects a content script into the active tab to extract necessary information like URL, title, text, and HTML.
 * Then, it calls `saveContent` to store this information in the database.
 * @returns {Promise<number>} A promise that resolves with the ID of the newly saved content item.
 * @throws {Error} If it fails to get the current tab, execute the script, or save the content.
 * @async
 */
async function handleSavePageContent() {
    const tab = await getCurrentTab(); // Get the active tab.
    try {
        // Execute a script in the context of the page to get its content.
        const injectionResults = await chrome.scripting.executeScript({
            target: { tabId: tab.id },
            func: () => ({ // This function runs in the page's context.
                url: window.location.href,
                title: document.title,
                text: document.body.innerText || "", // Get plain text content.
                html: document.documentElement.outerHTML || "" // Get full HTML content.
            })
        });
        // Validate the results from the content script.
        if (!injectionResults || !injectionResults[0] || !injectionResults[0].result) {
            throw new Error("Failed get page content from active tab.");
        }
        const pageContent = injectionResults[0].result;
        console.log("Page content received for saving:", pageContent.title);
        // Save the extracted content to the database.
        return await saveContent({
            type: 'page', // Specify the type of content being saved.
            content: pageContent.text,
            htmlContent: pageContent.html,
            url: pageContent.url,
            title: pageContent.title || 'Untitled Page' // Use page title or a default.
        });
    }
    catch (error) { console.error("Error in handleSavePageContent:", error); throw error; }
}

/**
 * Handles saving the currently selected text from the active page.
 * This is usually triggered by a user action, like a context menu click or a button in the UI.
 * It injects a script into the active tab to retrieve the selected text using `window.getSelection()`.
 * Then, it calls `saveContent` to store the selection.
 * @returns {Promise<number>} A promise that resolves with the ID of the newly saved selection item.
 * @throws {Error} If no text is selected, or if it fails to get the current tab, execute script, or save content.
 * @async
 */
async function handleSaveSelection() {
    const tab = await getCurrentTab(); // Get the active tab.
     try {
        // Execute a script to get the currently selected text.
        const injectionResults = await chrome.scripting.executeScript({
            target: { tabId: tab.id },
            func: () => window.getSelection().toString().trim() // Get selected text and trim whitespace.
        });
        // Validate results.
        if (!injectionResults || injectionResults.length === 0 || injectionResults[0].result === undefined) {
            throw new Error("Failed get selection from active tab.");
        }
        const selectedText = injectionResults[0].result;
        if (!selectedText) throw new Error("No text selected on the page.");
        console.log("Selection received for saving:", selectedText.substring(0, 100) + "...");
        // Save the selected text.
        return await saveContent({
            type: 'selection', // Specify the type.
            content: selectedText,
            url: tab.url, // URL of the page where selection was made.
            title: `Selection from: ${tab.title || 'Untitled Page'}` // Create a title for the selection.
        });
     } catch (error) { console.error("Error in handleSaveSelection:", error); throw error; }
}

/**
 * Handles saving the current page as a PDF document.
 * This function uses `generatePagePDF` (from `lib/pdf-generator.js`), which internally
 * utilizes `chrome.debugger` API (or `chrome.pageCapture.saveAsMHTML` as a fallback if PDF generation fails,
 * though current implementation focuses on direct PDF via DevTools Protocol).
 * It also extracts metadata from the page to store alongside the PDF.
 * @param {object} [options={}] - Optional parameters for PDF generation (e.g., `preset` name like 'standard', 'clean').
 *                                These presets are defined in `PDFPresets` in `lib/pdf-generator.js`.
 * @returns {Promise<number>} A promise that resolves with the ID of the newly saved PDF item in the database.
 * @throws {Error} If PDF generation or saving to the database fails.
 * @async
 */
async function handleSavePageAsPDF(options = {}) {
    console.log("[PDF] Starting page-to-PDF save process with options:", options);
    const tab = await getCurrentTab(); // Get the active tab.
    
    try {
        // Determine PDF options based on a preset or any directly provided options.
        const pdfOptionsToUse = options.preset ? PDFPresets[options.preset] : PDFPresets.standard;
        const finalPdfOptions = { ...pdfOptionsToUse, ...options }; // Merge, allowing specific options to override preset.
        
        console.log(`[PDF] Generating PDF for tab ${tab.id} using options:`, finalPdfOptions);
        
        // Generate PDF as a base64 encoded string using the utility function.
        const pdfBase64 = await generatePagePDF(tab.id, finalPdfOptions);
        
        if (!pdfBase64) {
            throw new Error("PDF generation returned empty or invalid data.");
        }
        
        // Convert base64 PDF to a data URL and estimate its file size.
        const pdfDataUrl = pdfToDataUrl(pdfBase64); // Prepends "data:application/pdf;base64,"
        const fileSize = estimatePDFSize(pdfBase64); // Estimates size from base64 string length.
        
        console.log(`[PDF] PDF generated successfully. Estimated Size: ${Math.round(fileSize / 1024)}KB`);
        
        // Attempt to get additional metadata from the page (URL, title, description, etc.).
        let pageMetadata = { url: tab.url, title: tab.title || 'Untitled Page' }; // Basic fallback.
        try {
            const injectionResults = await chrome.scripting.executeScript({
                target: { tabId: tab.id },
                func: () => ({ // This script runs in the page's context.
                    url: window.location.href,
                    title: document.title,
                    description: document.querySelector('meta[name="description"]')?.getAttribute('content') || null,
                    keywords: document.querySelector('meta[name="keywords"]')?.getAttribute('content') || null,
                    lang: document.documentElement.lang || null,
                    characterCount: document.body.innerText?.length || 0 // Approx character count of page text.
                })
            });
            
            if (injectionResults && injectionResults[0] && injectionResults[0].result) {
                pageMetadata = injectionResults[0].result;
            }
        } catch (metadataError) {
            console.warn("[PDF] Could not extract extended page metadata, using basic info:", metadataError);
        }
        
        // Prepare the content item object for saving to the database.
        const pdfItem = {
            type: 'pdf',
            title: `PDF: ${pageMetadata.title || 'Untitled Page'}`,
            content: pdfDataUrl, // The PDF content itself, as a data URL.
            contentType: 'application/pdf', // MIME type.
            url: pageMetadata.url, // Source URL of the page.
            
            fileSize: fileSize, // Estimated file size in bytes.
            pdfOptions: finalPdfOptions, // Store the options used for generation, for reference.
            
            // Additional metadata from the page.
            pageLang: pageMetadata.lang,
            pageDescription: pageMetadata.description,
            pageKeywords: pageMetadata.keywords,
            characterCount: pageMetadata.characterCount,
            
            // Standard fields, some may not be directly applicable to PDFs but are part of the schema.
            htmlContent: null, // PDFs don't have primary HTML content in this context.
            links: [], // Could potentially extract links from PDF content in future, but not currently.
            wordCount: null, // Not directly applicable like plain text.
            readingTimeMinutes: null, // Not directly applicable.
            analysis: null, // AI analysis is typically for text/images, not directly for PDF structure here.
            analysisCompleted: false,
            analysisFailed: false
        };
        
        console.log("[PDF] Saving PDF item to database:", pdfItem.title);
        const itemId = await saveContent(pdfItem); // Save the PDF item.
        
        console.log(`[PDF] PDF saved successfully with ID: ${itemId}`);
        return itemId;
        
    } catch (error) {
        console.error("[PDF] Error in handleSavePageAsPDF:", error);
        throw error; // Re-throw to be handled by the message listener's catch block.
    }
}

/**
 * Handles capturing the visible part of the current/active tab as a PNG image.
 * This uses `chrome.tabs.captureVisibleTab`.
 * @returns {Promise<number>} A promise that resolves with the ID of the newly saved screenshot item.
 * @throws {Error} If capturing the tab or saving the content fails, or if the tab has no window ID.
 * @async
 */
async function handleCaptureVisibleTab() {
    const tab = await getCurrentTab(); // Get the active tab.
    if (!tab.windowId) throw new Error("Current tab is missing a window ID, cannot capture.");
    try {
        // Capture the visible tab area; returns a data URL (PNG format by default).
        const dataUrl = await chrome.tabs.captureVisibleTab(tab.windowId, { format: "png" });
        if (!dataUrl) throw new Error("Tab capture returned empty data.");
        console.log("Visible tab captured successfully.");
        // Save the screenshot data.
        return await saveContent({
            type: 'screenshot',
            content: dataUrl, // The image data as a data URL.
            contentType: 'image/png',
            url: tab.url, // URL of the captured page.
            title: `Screenshot of ${tab.title || 'Untitled Page'}` // Create a title.
        });
    } catch (error) { console.error("Error in handleCaptureVisibleTab:", error); throw error; }
}

/**
 * Initiates the process for capturing a user-selected area of the page.
 * It sends a "START_AREA_SELECTION" message to the content script injected into the active tab.
 * The content script is then responsible for handling the UI for area selection.
 * @returns {Promise<object>} A promise that resolves with the response from the content script
 *                            (usually `{success: true, message: "Area selection started."}`).
 * @throws {Error} If it fails to get the current tab or if communication with the content script fails
 *                 (e.g., content script not injected or not responding).
 * @async
 */
async function handleInitiateAreaCapture() {
    const tab = await getCurrentTab(); // Get the active tab.
     try {
         console.log(`Sending START_AREA_SELECTION message to tab ID: ${tab.id}`);
         // Message the content script in the active tab to start the area selection process.
         const response = await chrome.tabs.sendMessage(tab.id, { type: "START_AREA_SELECTION" });
         console.log("Response from content script for INITIATE_AREA_CAPTURE:", response);
         if (response && response.success) {
             return { success: true, message: "Area selection successfully started in content script." };
         } else {
             throw new Error(response?.error || "Content script failed to initiate area selection.");
         }
     } catch (error) {
          console.error("Error initiating area capture via content script message:", error);
          // Provide a more user-friendly error if content script connection fails.
          if (error.message.includes("Could not establish connection") || error.message.includes("Receiving end does not exist")) {
              throw new Error("Could not communicate with the page. Please reload the page and try again.");
          }
          throw error; // Re-throw other errors.
     }
}

/**
 * Handles capturing a specific area of the page, based on coordinates and other data received from the content script.
 * After the user selects an area on the page (handled by a content script), the content script sends
 * the rectangle data (`rect`), `devicePixelRatio`, source `url`, and `title` to this function.
 * This function then captures the visible tab and crops it to the specified rectangle using `cropImageCanvas`.
 * @param {object} payload - An object containing details from the content script.
 * @param {object} payload.rect - The rectangle defining the area to crop {x, y, width, height}.
 * @param {number} payload.devicePixelRatio - The device pixel ratio of the display where selection was made.
 * @param {string} [payload.url] - The URL of the page, if provided by content script.
 * @param {string} [payload.title] - The title of the page, if provided by content script.
 * @param {chrome.tabs.Tab} tab - The tab object where the area capture was performed.
 * @returns {Promise<number>} A promise that resolves with the ID of the newly saved area screenshot.
 * @throws {Error} If input data is invalid, or if capturing, cropping, or saving fails.
 * @async
 */
async function handleCaptureArea(payload, tab) {
    const { rect, devicePixelRatio, url, title } = payload;
    // Validate received rectangle data.
    if (!rect || typeof rect.x !== 'number' || typeof rect.y !== 'number' || typeof rect.width !== 'number' || typeof rect.height !== 'number') {
        throw new Error("Invalid rectangle data received for area capture.");
    }
    if (!tab || !tab.windowId) throw new Error("Invalid tab information for area capture.");

    let effectiveDevicePixelRatio = devicePixelRatio;
    // Validate and default devicePixelRatio if necessary, as it's crucial for correct cropping.
    if (!effectiveDevicePixelRatio || typeof effectiveDevicePixelRatio !== 'number' || effectiveDevicePixelRatio <= 0) {
        console.warn("Invalid devicePixelRatio received, defaulting to 1. This might affect crop accuracy.");
        effectiveDevicePixelRatio = 1;
    }
    console.log("Received capture request for area:", rect, `DPR: ${effectiveDevicePixelRatio}`, "on Tab ID:", tab.id);
    try {
        // Capture the entire visible tab first.
        const fullDataUrl = await chrome.tabs.captureVisibleTab(tab.windowId, { format: "png" });
        if (!fullDataUrl) throw new Error("Full tab capture returned empty data for area crop.");

        console.warn("Attempting to crop image using OffscreenCanvas..."); // Log method.
        // Crop the full capture to the specified rectangle using an OffscreenCanvas.
        const croppedDataUrl = await cropImageCanvas(fullDataUrl, rect, effectiveDevicePixelRatio);
        console.log("Image cropped successfully using OffscreenCanvas.");

        // Save the cropped screenshot.
        return await saveContent({
            type: 'screenshot', // Still a screenshot, just a specific area.
            content: croppedDataUrl, // The cropped image data as a data URL.
            contentType: 'image/png',
            url: url || tab.url, // Use URL from payload if available (e.g., from an iframe), else from main tab.
            title: title ? `Area from: ${title}` : `Area Screenshot from ${tab.title || 'Untitled Page'}` // Create a descriptive title.
        });
    } catch (error) { console.error("Error capturing or cropping area screenshot:", error); throw error; }
}

/**
 * Generates key points (summary) for content items associated with a given tag ID.
 * It fetches relevant text-based items (pages, selections) for the tag,
 * combines their content (up to a certain limit), and sends this combined text
 * to an AI model (Gemini) for summarization. The generated key points are then
 * saved as a new content item of type "generated_analysis" and automatically tagged
 * with the source tag.
 * @param {number} tagId - The ID of the tag for which to generate key points.
 * @returns {Promise<object>} An object indicating success or failure.
 *          On success: `{ success: true, newId: number, sourceInfo: string, keyPoints: string }`
 *          On failure: `{ success: false, error: string }`
 * @async
 */
async function handleGetKeyPoints(tagId) {
    console.log(`[KeyPoints] Starting process for tag ID: ${tagId}`);
    let sourceInfo = `Generated from items tagged ID ${tagId}.`; // Default source information.
    let tagName = `Tag ${tagId}`; // Default tag name.
    let sourceItemIds = []; // IDs of items used to generate key points.
    let uniqueSourceUrls = new Set(); // To count unique source URLs.

    try {
        // Attempt to fetch the tag name for better source information.
        try {
            const tags = await getTagsByIds([tagId]);
            if (tags && tags.length > 0 && tags[0].name) {
                tagName = tags[0].name;
                sourceInfo = `Generated from items tagged "${tagName}" (ID ${tagId}).`;
            } else { console.warn(`[KeyPoints] Could not fetch name for tag ID: ${tagId}`); }
        } catch (tagFetchError) { console.warn(`[KeyPoints] Error fetching tag name for ID ${tagId}:`, tagFetchError); }

        // Get content items associated with the tag.
        const contentIds = await getContentIdsByTagId(tagId);
        if (!contentIds || contentIds.length === 0) {
            return { success: false, error: "No content items found for this tag." };
        }
        const items = await getContentItemsByIds(contentIds);

        // Filter for text-based items and limit the number of items for summary.
        const textItems = items
            .filter(item => (item.type === 'page' || item.type === 'selection') && item.content)
            .slice(0, MAX_ITEMS_FOR_SUMMARY);
        sourceItemIds = textItems.map(item => item.id);

        textItems.forEach(item => { if (item.url) uniqueSourceUrls.add(item.url); });
        const uniqueSourceCount = uniqueSourceUrls.size;

        if (textItems.length === 0) {
            return { success: false, error: "No text content found for this tag (only screenshots?)." };
        }

        // Update sourceInfo with details about the items used.
        sourceInfo = `Generated from ${textItems.length} item(s) (from ${uniqueSourceCount} unique source${uniqueSourceCount !== 1 ? 's' : ''}) tagged "${tagName}" (ID ${tagId}).`;
        if (items.length > textItems.length) sourceInfo += ` (Note: ${items.length - textItems.length} non-text items excluded.)`;
        if (contentIds.length > MAX_ITEMS_FOR_SUMMARY) sourceInfo += ` (Note: Limited to first ${MAX_ITEMS_FOR_SUMMARY} text items.)`;

        // Combine content from selected items, truncating if too long.
        let combinedText = textItems.map(item => `--- Item ${item.id} (${item.title || 'No Title'}) ---\n${item.content}\n\n`).join('');
        const MAX_CHARS = 15000; // Max characters for AI input to prevent overly long requests.
        if (combinedText.length > MAX_CHARS) {
             combinedText = combinedText.substring(0, MAX_CHARS) + "\n\n[... CONTENT TRUNCATED ...]";
             sourceInfo += " (Note: Input text was truncated.)";
        }

        // Prompt for AI summarization.
        const prompt = `Based *only* on the following text compiled from saved web content, please extract the main key points or provide a concise summary. Present the key points clearly, perhaps using bullet points:\n\n${combinedText}`;
        console.log(`[KeyPoints] Sending combined text to AI for tag ID: ${tagId}`);
        const analysisResponse = await analyzeTextWithGemini(combinedText, prompt); // Call to external AI API.
        const keyPoints = extractTextFromResult(analysisResponse); // Utility to get text from AI response.
        if (!keyPoints) {
            throw new Error("AI analysis did not return usable text content.");
        }
        console.log(`[KeyPoints] Received key points for tag ID: ${tagId}`);

        // Create a new content item for the generated key points.
        const newItem = {
            type: GENERATED_ITEM_TYPE, // Special type for AI-generated content.
            analysisType: "key_points",
            title: `Key Points for Tag: "${tagName}"`,
            content: keyPoints,
            sourceTagIds: [tagId], // Link back to the source tag.
            sourceItemIds: sourceItemIds, // Link back to source items.
            url: null, pageLang: null, pageDescription: null, pageKeywords: null, links: [], htmlContent: null,
            wordCount: keyPoints.split(/\s+/).filter(Boolean).length,
            readingTimeMinutes: Math.ceil(keyPoints.split(/\s+/).filter(Boolean).length / 200),
            contentType: null, analysis: null, analysisCompleted: true, analysisFailed: false,
            tags: [tagName] // Automatically add the source tag to the new item.
        };
        const newId = await saveContent(newItem); // Save the new item.

        // After saving, ensure the source tag is formally linked to this new item in the database.
        try {
            const addedTagId = await addTag(tagName); // Get or create the tag.
            await linkTagToContent(newId, addedTagId); // Link it.
            console.log(`[KeyPoints] Successfully linked generated item ${newId} with tag "${tagName}".`);
        } catch (tagLinkError) {
            // Log error but don't fail the whole operation if only linking fails.
            console.error(`[KeyPoints] Failed to link generated item ${newId} with tag "${tagName}":`, tagLinkError);
        }
        
        console.log(`[KeyPoints] Saved generated key points as new item ID: ${newId}`);

        return {
            success: true,
            newId: newId,
            sourceInfo: sourceInfo,
            keyPoints: keyPoints
        };

    } catch (error) {
        console.error(`[KeyPoints] Error during key points generation/saving for tag ${tagId}:`, error);
        return { success: false, error: error.message || "An unknown error occurred generating key points." };
    }
}

// --- Core Logic Functions ---

/**
 * Saves a content item to the database.
 * This is a central function for persisting any type of content (page, selection, screenshot, PDF, generated analysis).
 * It calculates word count and estimated reading time for text-based items.
 * If `item.tags` (an array of tag names) is provided, it ensures these tags exist and links them to the new item.
 * If the item is a screenshot, it triggers a background AI analysis (`analyzeScreenshotAndUpdate`).
 * Finally, it updates `lastSaveTimestamp` in local storage to signal UI components to refresh.
 *
 * @param {object} item - The content item object to save.
 *   Common properties:
 *   - `type` (string): Type of content (e.g., 'page', 'selection', 'screenshot', 'pdf', 'generated_analysis').
 *   - `content` (string): The main content (text, data URL for images/PDFs).
 *   - `title` (string): Title of the item.
 *   - `url` (string|null): Source URL, if applicable.
 *   - `tags` (Array<string>, optional): Array of tag names to associate with this item.
 *   Other properties might be specific to the item type (e.g., `htmlContent`, `fileSize`, `sourceTagIds`).
 * @returns {Promise<number>} A promise that resolves with the ID of the newly saved content item.
 * @throws {Error} If saving to the database via `addContentItem` fails or other critical errors occur.
 * @async
 */
async function saveContent(item) {
    // Calculate word count and reading time for text-based content.
    if ((item.type === 'page' || item.type === 'selection' || item.type === GENERATED_ITEM_TYPE) && item.content && typeof item.content === 'string') {
        try {
            item.wordCount = item.content.split(/\s+/).filter(Boolean).length;
            item.readingTimeMinutes = Math.ceil(item.wordCount / 200); // Assume 200 WPM reading speed.
        } catch (statError) { console.error("Error calculating stats for item:", item.title, statError); item.wordCount = null; item.readingTimeMinutes = null; }
    } else if (item.type === 'screenshot' || item.type === 'pdf') {
        // These types don't have direct word counts/reading times based on their primary content.
        item.wordCount = null;
        item.readingTimeMinutes = null;
    }

    // Create a log-friendly version of the item (truncate long content for logging).
    const logItem = { ...item };
    if (logItem.content && typeof logItem.content === 'string' && (logItem.content.startsWith('data:image') || logItem.content.startsWith('data:application/pdf'))) {
        logItem.content = logItem.content.substring(0, 80) + '...[binaryData]'; // Truncate binary data URL
    } else if (logItem.content && typeof logItem.content === 'string') {
        logItem.content = logItem.content.substring(0, 150) + (logItem.content.length > 150 ? '...' : ''); // Truncate text
    }
    if (logItem.htmlContent) {
        logItem.htmlContent = logItem.htmlContent.substring(0, 150) + '...[html]'; // Truncate HTML
    } else {
         logItem.htmlContent = undefined; // Ensure it's not logged if null/empty to keep logs cleaner.
    }

    console.log("Attempting to save item with processed data:", { // Log key details of the item being saved.
        type: logItem.type,
        title: logItem.title,
        url: logItem.url,
        contentPreview: logItem.content, // Log truncated content
        htmlPreview: logItem.htmlContent, // Log truncated HTML
        wordCount: item.wordCount,
        readingTimeMinutes: item.readingTimeMinutes,
        analysisType: logItem.analysisType,
        sourceTagIds: logItem.sourceTagIds,
        sourceItemIds: logItem.sourceItemIds,
        fileSize: logItem.fileSize,
        tags: logItem.tags // Log tags if present for initial tagging.
    });

    try {
        // Add the item to the database using the imported db.js function.
        const itemId = await addContentItem(item);
        console.log(`Item saved successfully with ID: ${itemId}. Type: ${item.type}`);

        // Handle initial tags if they were provided directly in the item object during its creation.
        if (item.tags && Array.isArray(item.tags) && item.tags.length > 0) {
            console.log(`Processing ${item.tags.length} initial tags for item ID ${itemId}.`);
            for (const tagName of item.tags) {
                try {
                    const tagId = await addTag(tagName); // Ensure tag exists in 'tags' table, get its ID.
                    await linkTagToContent(itemId, tagId); // Link the new item to this tag in 'content_tags' table.
                    console.log(`Initial tag "${tagName}" (ID: ${tagId}) successfully linked to item ID ${itemId}.`);
                } catch (tagError) {
                    console.error(`Failed to add/link initial tag "${tagName}" to item ID ${itemId}:`, tagError);
                }
            }
        }

        // Update a timestamp in local storage. This can be observed by UI components (e.g., side panel, options page)
        // to trigger a refresh or update their views when new content is saved.
        chrome.storage.local.set({ lastSaveTimestamp: Date.now() }, () => {
            if (chrome.runtime.lastError) console.error("Error setting lastSaveTimestamp after saving content:", chrome.runtime.lastError);
            else console.log("lastSaveTimestamp updated to signal UI refresh.");
        });

        // If the saved item is a screenshot and has image data, trigger AI analysis in the background.
        // This is done asynchronously and doesn't block the completion of the saveContent function.
        if (item.type === 'screenshot' && item.content && typeof item.content === 'string' && item.content.startsWith('data:image')) {
            console.log(`Screenshot saved (ID: ${itemId}). Triggering background AI analysis.`);
            analyzeScreenshotAndUpdate(itemId, item.content).catch(analysisError => {
                 // Log error and update the item in DB to reflect that analysis has failed.
                 console.error(`[Item ID: ${itemId}] Background screenshot analysis pipeline failed:`, analysisError);
                 updateContentItem(itemId, {
                     analysis: { error: `Background analysis failed: ${analysisError.message}` },
                     analysisCompleted: false, // Mark as not completed
                     analysisFailed: true      // Mark as failed
                    })
                    .catch(dbUpdateError => console.error(`[Item ID: ${itemId}] Failed to update database with analysis error status:`, dbUpdateError));
            });
        }
        return itemId; // Return the ID of the newly saved item.
    } catch (error) {
        console.error("Critical error during saveContent execution:", error);
        throw error; // Re-throw the error to be handled by the caller.
    }
}

/**
 * Performs AI analysis on a screenshot image using Google Gemini.
 * It requests multiple types of analysis (general description, diagram/chart extraction, layout analysis)
 * by sending different prompts to the `analyzeImageWithGemini` API utility.
 * The results are then consolidated and the corresponding content item in the database is updated.
 * This function is designed to run in the background, often triggered after a screenshot is saved.
 *
 * @param {number} itemId - The ID of the screenshot content item in the database to update with analysis results.
 * @param {string} imageDataUrl - The data URL of the screenshot image to be analyzed.
 * @async
 */
async function analyzeScreenshotAndUpdate(itemId, imageDataUrl) {
    console.log(`[${itemId}] Starting analysis pipeline...`);
    const analysisResults = {}; // Object to store results from different analysis types.
    let analysisOverallSuccess = true; // Flag to track if all analyses succeeded.

    try {
        // Define prompts for different types of analysis.
        const prompts = {
            description: "Describe this image concisely.",
            diagram_chart: "Analyze this image. If it contains a chart, graph, or diagram, extract the key data points, labels, and title into a structured JSON object. If not, respond with {\"contains_diagram\": false}.",
            layout: "Analyze the layout of this webpage screenshot. Identify key structural elements (like header, footer, main content, sidebar, navigation, forms) and their approximate locations (e.g., top, bottom, left, right, center). Provide the analysis as a JSON object like {\"header\": \"top\", \"main_content\": \"center\", ...}. If it's not a webpage screenshot, respond with {\"is_webpage_layout\": false}.",
        };

        // Perform description analysis.
        try {
            console.log(`[${itemId}] Requesting description...`);
            const r = await analyzeImageWithGemini(imageDataUrl, prompts.description);
            analysisResults.description = extractTextFromResult(r); // Utility to get text from AI response.
            console.log(`[${itemId}] Description received.`);
        } catch (e) { console.error(`[${itemId}] Desc analysis failed:`, e); analysisResults.descriptionError = e.message; analysisOverallSuccess = false; }

        // Perform diagram/chart analysis.
        try {
            console.log(`[${itemId}] Requesting diagram/chart analysis...`);
            const r = await analyzeImageWithGemini(imageDataUrl, prompts.diagram_chart);
            const t = extractTextFromResult(r);
            if (t) {
                analysisResults.diagramData = tryParseJson(t, "diagram/chart"); // Utility to parse JSON from AI response.
                console.log(`[${itemId}] Diagram/Chart analysis processed.`);
                // If AI indicates no diagram, nullify the result.
                if (analysisResults.diagramData?.contains_diagram === false) analysisResults.diagramData = null;
            } else { analysisResults.diagramData = { error: "No text content received." }; analysisOverallSuccess = false; }
        } catch (e) { console.error(`[${itemId}] Diagram/Chart analysis failed:`, e); analysisResults.diagramError = e.message; analysisOverallSuccess = false; }

        // Perform layout analysis.
        try {
            console.log(`[${itemId}] Requesting layout analysis...`);
            const r = await analyzeImageWithGemini(imageDataUrl, prompts.layout);
            const t = extractTextFromResult(r);
            if (t) {
                analysisResults.layout = tryParseJson(t, "layout");
                console.log(`[${itemId}] Layout analysis processed.`);
                // If AI indicates not a webpage, nullify the result.
                if (analysisResults.layout?.is_webpage_layout === false) analysisResults.layout = null;
            } else { analysisResults.layout = { error: "No text content received." }; analysisOverallSuccess = false; }
        } catch (e) { console.error(`[${itemId}] Layout analysis failed:`, e); analysisResults.layoutError = e.message; analysisOverallSuccess = false; }

        console.log(`[${itemId}] Updating database item with analysis results:`, analysisResults);
        // Update the content item in the database with the analysis results.
        await updateContentItem(itemId, { analysis: analysisResults, analysisCompleted: true, analysisFailed: !analysisOverallSuccess });
        console.log(`[${itemId}] Database item updated with analysis.`);
        // Update timestamp to signal UI refresh for analysis completion.
        chrome.storage.local.set({ lastAnalysisTimestamp: Date.now() }, () => { if (chrome.runtime.lastError) console.error("Error setting lastAnalysisTimestamp:", chrome.runtime.lastError); });
    } catch (error) {
        // Handle critical failures in the pipeline.
        console.error(`[${itemId}] Critical failure in analysis pipeline:`, error);
        try {
            await updateContentItem(itemId, { analysis: { error: `Critical failure: ${error.message}` }, analysisCompleted: false, analysisFailed: true });
        } catch (dbError) { console.error(`[${itemId}] Failed to update DB with critical error status:`, dbError); }
    }
}

/**
 * Crops an image from a data URL to a specified rectangle using an OffscreenCanvas.
 * This is used for area screenshots.
 * @param {string} dataUrl - The data URL of the source image (full screenshot).
 * @param {object} rect - An object with `x, y, width, height` defining the crop area.
 * @param {number} devicePixelRatio - The device pixel ratio of the screen where the rect was defined.
 * @returns {Promise<string>} A promise that resolves with the data URL of the cropped image (PNG format).
 * @throws {Error} If any step of fetching, decoding, cropping, or encoding fails.
 * @async
 */
async function cropImageCanvas(dataUrl, rect, devicePixelRatio) {
    console.warn("Attempting crop via direct Canvas/createImageBitmap...");
    let imageBitmap; // To hold the decoded image.
    try {
        // Fetch the image data from the data URL.
        const response = await fetch(dataUrl);
        if (!response.ok) throw new Error(`Fetch failed: ${response.statusText}`);
        const imageBlob = await response.blob(); // Convert to Blob.
        console.log(`Canvas Crop: Blob created (type: ${imageBlob.type}, size: ${imageBlob.size})`);
        imageBitmap = await createImageBitmap(imageBlob); // Decode Blob into ImageBitmap for efficient drawing.
        console.log(`Canvas Crop: ImageBitmap created (${imageBitmap.width}x${imageBitmap.height})`);

        // Calculate canvas dimensions for the cropped image, considering device pixel ratio.
        const canvasWidth = Math.round(rect.width * devicePixelRatio);
        const canvasHeight = Math.round(rect.height * devicePixelRatio);
        if (canvasWidth <= 0 || canvasHeight <= 0) {
             imageBitmap.close(); // Release ImageBitmap resources.
             throw new Error(`Invalid canvas dimensions calculated: ${canvasWidth}x${canvasHeight}`);
        }

        // Create an OffscreenCanvas for drawing.
        const canvas = new OffscreenCanvas(canvasWidth, canvasHeight);
        const ctx = canvas.getContext('2d');
        if (!ctx) throw new Error("Failed to get 2D context.");

        // Calculate source coordinates and dimensions for drawing from the ImageBitmap.
        const sx = Math.round(rect.x * devicePixelRatio);
        const sy = Math.round(rect.y * devicePixelRatio);
        const sWidth = Math.round(rect.width * devicePixelRatio);
        const sHeight = Math.round(rect.height * devicePixelRatio);
        console.log(`Canvas Crop: Canvas Size = ${canvas.width}x${canvas.height}`);
        console.log(`Canvas Crop: Draw Params: sx=${sx}, sy=${sy}, sWidth=${sWidth}, sHeight=${sHeight}`);

        // Clamp source dimensions to be within the bounds of the ImageBitmap to prevent errors.
        const clamped_sx = Math.max(0, sx);
        const clamped_sy = Math.max(0, sy);
        const clamped_sWidth = Math.max(0, Math.min(sWidth, imageBitmap.width - clamped_sx));
        const clamped_sHeight = Math.max(0, Math.min(sHeight, imageBitmap.height - clamped_sy));

        if (clamped_sWidth <= 0 || clamped_sHeight <= 0) {
             // If clamped dimensions are invalid, return a 1x1 transparent pixel (or handle as error).
             console.warn("Canvas Crop: Clamped source dimensions are zero or negative, cannot draw.");
             imageBitmap.close();
             return "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII="; // 1x1 transparent PNG
        }
        console.log(`Canvas Crop: Clamped Draw Params: sx=${clamped_sx}, sy=${clamped_sy}, sWidth=${clamped_sWidth}, sHeight=${clamped_sHeight}`);

        // Draw the specified portion of the ImageBitmap onto the OffscreenCanvas.
        ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas first.
        ctx.drawImage(imageBitmap, clamped_sx, clamped_sy, clamped_sWidth, clamped_sHeight, 0, 0, canvas.width, canvas.height);
        console.log("Canvas Crop: ImageBitmap drawn.");
        imageBitmap.close(); // Release ImageBitmap resources.

        // Convert the OffscreenCanvas content to a Blob (PNG format).
        const resultBlob = await canvas.convertToBlob({ type: 'image/png' });
        if (!resultBlob) throw new Error("Canvas generated null blob.");
        console.log("Canvas Crop: Blob converted.");

        // Convert the Blob to a data URL.
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onloadend = () => {
                if (reader.result && typeof reader.result === 'string' && reader.result.startsWith('data:image/png')) {
                    console.log("Canvas Crop: Blob converted to data URL.");
                    resolve(reader.result);
                } else { reject(new Error("FileReader failed to produce valid data URL.")); }
            };
            reader.onerror = (e) => { console.error("Canvas Crop: FileReader error:", e); reject(new Error(`FileReader error: ${e}`)); };
            reader.readAsDataURL(resultBlob);
        });
    } catch (error) {
        console.error("Error during cropImageCanvas:", error);
        if (imageBitmap?.close) imageBitmap.close(); // Ensure ImageBitmap is closed on error.
        throw error;
    }
}

// --- Utility Functions ---

/**
 * Safely extracts text content from a Gemini AI analysis result object.
 * The Gemini API response structure can be nested. This function attempts to
 * access `result.candidates[0].content.parts[0].text`.
 * @param {object} result - The result object from `analyzeImageWithGemini` or `analyzeTextWithGemini`.
 *                          It's expected to follow the Gemini API's response schema.
 * @returns {string|null} The extracted text string if found, otherwise null.
 *                        Logs a warning if extraction fails or if the path is invalid.
 */
function extractTextFromResult(result) {
    try {
        // Safely access nested properties to get the text part of the AI response.
        const text = result?.candidates?.[0]?.content?.parts?.[0]?.text;
        if (typeof text === 'string') {
            return text;
        }
    } catch (e) {
        // Log any error occurring during property access.
        console.error("Error accessing text from AI result object:", e, "Result object:", result);
    }
    // Warn if text could not be extracted, which might indicate an unexpected API response format.
    console.warn("Could not extract text from AI result. Input object:", result);
    return null;
}

/**
 * Attempts to parse a string as JSON.
 * It first checks if the string is wrapped in markdown-style JSON code blocks (e.g., ```json\n{...}\n```)
 * and extracts the content within if so.
 * If direct parsing fails or if the input doesn't appear to be JSON (doesn't start with '{' or '['),
 * it returns an object containing the original text as a summary and includes a parse error message if applicable.
 * This makes the function resilient to common ways AI models might format JSON output within a larger text response.
 *
 * @param {string} text - The string potentially containing JSON to parse.
 * @param {string} [context="data"] - A context string for logging purposes, to help identify which part of the code
 *                                    is attempting the JSON parse.
 * @returns {object|null} The parsed JSON object if successful.
 *                        If parsing fails or input is not valid JSON-like, returns an object
 *                        of the form `{ text_summary: string, parse_error?: string }`.
 *                        Returns `null` if the input `text` itself is null or not a string.
 */
function tryParseJson(text, context = "data") {
    if (!text || typeof text !== 'string') {
        console.warn(`[${context}] Invalid input for JSON parsing: input is null or not a string.`);
        return null;
    }

    let jsonString = text.trim();

    // Check for and extract JSON if it's wrapped in markdown-style code blocks.
    // This regex looks for ```json ... ``` and captures the content in between.
    const markdownMatch = jsonString.match(/```json\s*([\s\S]*?)\s*```/);
    if (markdownMatch && markdownMatch[1]) {
        jsonString = markdownMatch[1].trim(); // Use the extracted content.
        console.log(`[${context}] Extracted JSON content from markdown code block.`);
    }

    // Basic heuristic: if the string doesn't start with '{' or '[', it's unlikely to be valid JSON.
    // This helps avoid unnecessary JSON.parse attempts on plain text summaries.
    if (!jsonString.startsWith('{') && !jsonString.startsWith('[')) {
        console.warn(`[${context}] Text content does not appear to be standard JSON format. Original text (first 200 chars):`, text.substring(0, 200));
        // Return the original text as a summary if it's not JSON-like.
        return { text_summary: text };
    }

    try {
        // Attempt to parse the (potentially extracted) JSON string.
        const parsedJson = JSON.parse(jsonString);
        console.log(`[${context}] Successfully parsed JSON string.`);
        return parsedJson;
    } catch (e) {
        // Log detailed error information if parsing fails.
        console.error(`[${context}] Failed to parse JSON string. Error:`, e.message,
                      "Attempted to parse (first 200 chars):", jsonString.substring(0, 200),
                      "Original text (first 200 chars):", text.substring(0, 200));
        // Return an object containing the original text and the parse error message.
        return { text_summary: text, parse_error: e.message };
    }
}

// --- Initialization on Startup ---

// On service worker startup, retrieve the 'autoBackup' setting from local storage.
// If a schedule (e.g., 'daily', 'weekly', 'monthly') is set (i.e., not 'disabled'),
// it calls `updateAutoBackupSchedule` to ensure the Chrome alarm for auto-backup is correctly
// configured or re-established. This is important because alarms do not persist across
// browser restarts if the extension is not running.
chrome.storage.local.get(['autoBackup'], (result) => {
    if (result.autoBackup && result.autoBackup !== 'disabled') {
        console.log(`[Startup] Auto-backup setting found: ${result.autoBackup}. Updating/initializing alarm schedule.`);
        updateAutoBackupSchedule(result.autoBackup);
    } else {
        console.log(`[Startup] Auto-backup is disabled or not set. No alarm schedule to initialize.`);
    }
});

// The following functions (handleGeneratePDFReport, buildReportHTML, etc.) are related to
// generating a PDF report for a specific tag. They were added in a later development stage.
// Comments for these will detail their specific roles in the report generation process.

// Add these functions at the end of background.js (before the final console.log)

/**
 * Handles the generation of a comprehensive PDF report for all content items associated with a specific tag.
 * The process involves:
 * 1. Fetching the tag's name and all related content items.
 * 2. Retrieving or generating key points/summary for the tagged content.
 * 3. Constructing an HTML document that includes the key points, an overview of the items, and detailed
 *    information for each item (including its content or a representation of it, and any AI analysis).
 * 4. Converting this HTML document into a PDF.
 * 5. Initiating a download of the generated PDF for the user.
 *
 * This function orchestrates calls to several helper functions for specific tasks like
 * HTML building (`buildReportHTML`), filename generation (`generateReportFilename`),
 * and HTML-to-PDF conversion (`generatePDFFromHTML`).
 *
 * @param {number} tagId - The ID of the tag for which the report is to be generated.
 * @returns {Promise<object>} A promise that resolves to an object indicating the outcome.
 *          On success: `{ success: true, filename: string, message: string }`
 *          On failure: `{ success: false, error: string }`
 * @async
 */
async function handleGeneratePDFReport(tagId) {
    console.log(`[PDFReport] Starting PDF report generation for tag ID: ${tagId}`);
    
    try {
        // Step 1: Get tag name.
        let tagName = `Tag ${tagId}`; // Default name.
        let keyPointsContent = null;
        let sourceInfo = ''; // Information about the source of key points.
        
        try {
            const tags = await getTagsByIds([tagId]);
            if (tags && tags.length > 0 && tags[0].name) {
                tagName = tags[0].name;
            }
        } catch (tagFetchError) {
            console.warn(`[PDFReport] Could not fetch name for tag ID: ${tagId}`, tagFetchError);
        }

        // Step 2: Get all content items for this tag.
        const contentIds = await getContentIdsByTagId(tagId);
        if (!contentIds || contentIds.length === 0) {
            return { success: false, error: "No content items found for this tag." };
        }
        const allItems = await getContentItemsByIds(contentIds);
        if (!allItems || allItems.length === 0) {
            return { success: false, error: "Could not retrieve content items for this tag." };
        }

        // Step 3: Check for existing key points or generate new ones.
        // Look for a previously generated key points item for this tag.
        const existingKeyPoints = allItems.find(item => 
            item.type === GENERATED_ITEM_TYPE && 
            item.analysisType === 'key_points' &&
            item.sourceTagIds && item.sourceTagIds.includes(tagId)
        );

        if (existingKeyPoints) {
            console.log(`[PDFReport] Using existing key points from item ID: ${existingKeyPoints.id}`);
            keyPointsContent = existingKeyPoints.content;
            sourceInfo = existingKeyPoints.sourceInfo || `Generated from items tagged "${tagName}" (ID ${tagId}).`;
        } else {
            // If no existing key points, generate them now.
            console.log(`[PDFReport] No existing key points found, generating new ones...`);
            const keyPointsResult = await handleGetKeyPoints(tagId); // Re-use the key point generation logic.
            if (keyPointsResult.success) {
                keyPointsContent = keyPointsResult.keyPoints;
                sourceInfo = keyPointsResult.sourceInfo;
                console.log(`[PDFReport] Generated new key points successfully`);
            } else {
                console.warn(`[PDFReport] Failed to generate key points: ${keyPointsResult.error}`);
                keyPointsContent = "Key points could not be generated for this report."; // Fallback content.
                sourceInfo = `Report generated from ${allItems.length} items tagged "${tagName}" (ID ${tagId}).`;
            }
        }

        // Step 4: Build the HTML content for the PDF report.
        const reportHTML = await buildReportHTML(tagName, tagId, allItems, keyPointsContent, sourceInfo);
        
        // Step 5: Generate the PDF from the HTML and initiate download.
        const filename = generateReportFilename(tagName); // Create a standardized filename.
        const pdfResult = await generatePDFFromHTML(reportHTML, filename); // This function handles conversion and download.
        
        console.log(`[PDFReport] PDF report generated successfully: ${filename}`);
        return { 
            success: true, 
            filename: filename,
            message: `PDF report generated successfully for tag "${tagName}"`
        };

    } catch (error) {
        console.error(`[PDFReport] Error generating PDF report for tag ${tagId}:`, error);
        return { success: false, error: error.message || "An unknown error occurred generating PDF report." };
    }
}

/**
 * Builds the HTML content for the PDF report.
 * This includes a header, key points section, tags analysis, and then iterates through each item.
 * @param {string} tagName - The name of the tag for the report.
 * @param {number} tagId - The ID of the tag.
 * @param {Array<object>} items - Array of content items for the report.
 * @param {string} keyPointsContent - The generated key points/summary for the tag.
 * @param {string} sourceInfo - Information about the source of the key points.
 * @returns {Promise<string>} The complete HTML string for the report.
 * @async
 */
async function buildReportHTML(tagName, tagId, items, keyPointsContent, sourceInfo) {
    const now = new Date();
    const dateRange = getDateRange(items); // Get a string for the date range of items.
    
    // Sort items by creation date (most recent first is a common preference for reports).
    const sortedItems = items.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
    
    // Gather all unique tags from all items included in this report.
    // This is used to display a list of "related topics" or other tags present in the compiled content.
    const allTagsInReport = new Set();
    for (const item of sortedItems) { // Iterate through each item that will be in the report.
        try {
            const itemTagIds = await getTagIdsByContentId(item.id); // Get IDs of tags linked to this item.
            if (itemTagIds && itemTagIds.length > 0) {
                const itemTagsObjects = await getTagsByIds(itemTagIds); // Get full tag objects for these IDs.
                itemTagsObjects.forEach(tagObj => allTagsInReport.add(tagObj.name)); // Add tag names to the set.
            }
        } catch (error) {
            // Log if fetching tags for a specific item fails, but continue building the report.
            console.warn(`[PDFReport] Could not fetch tags for item ${item.id} during HTML build:`, error);
        }
    }
    // Filter out the main report tag itself to list only other "related" tags.
    const otherTags = Array.from(allTagsInReport).filter(tName => tName !== tagName).sort();
    
    // Introductory text for the report, providing context about the tool and the report's content.
    // This text is designed to be part of the PDF's preamble.
    const introStatement = `
This report was generated using JC WebInsight c2025, an AI-powered research compilation tool.

JC WebInsight allows users to capture, analyze, and organize web content including full pages, text selections,
screenshots, and custom area captures. The extension leverages Google Gemini AI to analyze visual content,
extract diagrams, and generate insights from collected materials.

This report compiles ${sortedItems.length} item(s) tagged with '${escapeHTML(tagName)}' collected between ${dateRange}. The following key points summarize the collected research:`;

    // Start building the HTML string for the report.
    let reportHTML = `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JC WebInsight Report - ${escapeHTML(tagName)}</title>
    <style>
        /* Basic CSS styling for the PDF report. This is embedded directly into the HTML. */
        body { font-family: Arial, sans-serif; line-height: 1.6; margin: 40px; color: #333; }
        h1 { color: #0366d6; border-bottom: 2px solid #0366d6; padding-bottom: 10px; }
        h2 { color: #586069; border-bottom: 1px solid #e1e4e8; padding-bottom: 5px; margin-top: 30px; }
        h3 { color: #24292e; margin-top: 25px; }
        .intro-section { background-color: #f6f8fa; padding: 20px; border-radius: 6px; margin-bottom: 30px; }
        .key-points-section { background-color: #e6ffed; padding: 20px; border-radius: 6px; margin-bottom: 30px; border-left: 4px solid #1f883d; }
        .source-info { font-size: 0.9em; color: #586069; font-style: italic; margin-top: 15px; }
        .item-break { font-weight: bold; color: #0366d6; margin: 30px 0 20px 0; font-size: 1.1em; text-align: center; border-top: 1px dashed #ccc; padding-top: 20px;} /* Visual separator between items */
        .item-container { margin-bottom: 40px; border: 1px solid #e1e4e8; border-radius: 6px; padding: 20px; page-break-inside: avoid; } /* Tries to keep each item block on a single page */
        .item-header { background-color: #f6f8fa; margin: -20px -20px 20px -20px; padding: 15px 20px; border-radius: 6px 6px 0 0; border-bottom: 1px solid #e1e4e8;}
        .item-title { font-size: 1.2em; font-weight: bold; color: #24292e; margin: 0; }
        .item-meta { font-size: 0.9em; color: #586069; margin: 5px 0; } /* For URL, type, date */
        .item-tags { margin-top: 10px; }
        .tag { background-color: #0366d6; color: white; padding: 2px 8px; border-radius: 12px; font-size: 0.8em; margin-right: 5px; display: inline-block; }
        .tag-focus { background-color: #1f883d; font-weight: bold; } /* Highlight the main tag */
        .content-section { margin: 20px 0; }
        .ai-analysis { background-color: #fff3cd; padding: 15px; border-radius: 4px; margin: 15px 0; border-left: 4px solid #ffc107; } /* Styling for AI analysis sections */
        .screenshot-img { max-width: 100%; height: auto; border: 1px solid #e1e4e8; border-radius: 4px; margin: 10px 0; } /* Styling for screenshot images */
        .content-text { background-color: #f8f9fa; padding: 15px; border-radius: 4px; font-family: monospace; white-space: pre-wrap; word-wrap: break-word; max-height: 300px; overflow-y: auto; } /* Styling for text content blocks, with scrolling for long text */
        .pdf-indicator { color: #d73027; font-weight: bold; font-size: 1.1em; } /* Styling for PDF item indicators */
    </style>
</head>
<body>
    <h1>JC WebInsight Research Report</h1>
    
    <div class="intro-section">
        <h2>Report Overview</h2>
        <p><strong>Topic:</strong> ${escapeHTML(tagName)}</p>
        <p><strong>Generated:</strong> ${now.toLocaleString()}</p>
        <p><strong>Items Analyzed:</strong> ${sortedItems.length}</p>
        <p><strong>AI Analysis Engine:</strong> Google Gemini 1.5 (Primarily for screenshots and key points generation)</p>
        <br>
        <p>${introStatement}</p> <!-- The previously defined introStatement, already HTML-escaped where needed -->
    </div>

    <div class="key-points-section">
        <h2>Key Points Summary</h2>
        <div style="white-space: pre-wrap;">${escapeHTML(keyPointsContent)}</div> <!-- Display key points, preserving whitespace -->
        <div class="source-info">${escapeHTML(sourceInfo)}</div> <!-- Information about how key points were derived -->
    </div>

    <h2>Tags Analysis</h2>
    <p><strong>Report Focus:</strong> <span class="tag tag-focus">${escapeHTML(tagName)}</span> (Selected tag)</p>
    ${otherTags.length > 0 ? `<p><strong>Related Topics:</strong> ${otherTags.map(t => `<span class="tag">${escapeHTML(t)}</span>`).join(' ')}</p>` : ''}
    <p><strong>Total Items in Report:</strong> ${sortedItems.length} | <strong>Date Range of Items:</strong> ${dateRange}</p>

    <h2>Research Compilation Details</h2>
`;

    // Iterate through each sorted item and append its HTML representation to the report.
    for (let i = 0; i < sortedItems.length; i++) {
        const item = sortedItems[i];
        // `buildItemHTML` is an async function that creates the HTML block for a single content item.
        // It takes the item, its number in the report, the main tag name, and tag ID for context.
        reportHTML += await buildItemHTML(item, i + 1, tagName, tagId);
    }

    reportHTML += `
</body>
</html>`;

    return reportHTML;
}

/**
 * Builds the HTML representation for a single content item to be included in the PDF report.
 * This function formats the item's metadata (title, URL, date, type, tags), its primary content
 * (text, screenshot image, or an indicator for PDF files), and any associated AI analysis results.
 *
 * @param {object} item - The content item object from the database.
 * @param {number} itemNumber - The sequential number of the item in the report (e.g., "ITEM #1").
 * @param {string} focusTagName - The name of the primary tag for the report. This tag is highlighted
 *                                when displayed with the item.
 * @param {number} focusTagId - The ID of the primary tag. (Currently used implicitly by `focusTagName`
 *                              for highlighting, direct use might be for more complex logic not yet implemented).
 * @returns {Promise<string>} A promise that resolves to an HTML string representing the content item.
 * @async
 */
async function buildItemHTML(item, itemNumber, focusTagName, focusTagId) {
    const itemDate = new Date(item.createdAt).toLocaleString(); // Format creation date for display.
    
    // Fetch and prepare tags associated with this specific item.
    let itemTagsObjects = [];
    try {
        const tagIds = await getTagIdsByContentId(item.id); // Get IDs of tags linked to this item.
        if (tagIds && tagIds.length > 0) {
            itemTagsObjects = await getTagsByIds(tagIds); // Get full tag objects.
        }
    } catch (error) {
        console.warn(`[PDFReport] Could not fetch tags for item ${item.id} during its HTML build:`, error);
    }

    // Create HTML for displaying tags. The focusTagName (main tag of the report) is given a special style.
    const tagsHTML = itemTagsObjects.map(tagObj =>
        `<span class="tag ${tagObj.name === focusTagName ? 'tag-focus' : ''}">${escapeHTML(tagObj.name)}</span>`
    ).join(' ');

    let contentHTML = ''; // Variable to hold HTML for the item's main content.
    let analysisHTML = ''; // Variable to hold HTML for any AI analysis of the item.

    // Build the content display based on the item's type.
    switch (item.type) {
        case 'page': // Full saved web page content.
        case 'selection': // Saved text selection.
            contentHTML = `<div class="content-text">${escapeHTML(item.content || 'No textual content available.')}</div>`;
            if (item.wordCount) { // Display word count and estimated reading time if available.
                contentHTML += `<p><small>Word Count: ${item.wordCount}, Est. Reading Time: ${item.readingTimeMinutes} min</small></p>`;
            }
            break;

        case 'screenshot': // Saved screenshot.
            contentHTML = `<img src="${item.content}" alt="Screenshot content from item ${item.id}" class="screenshot-img">`;
            // If AI analysis results exist for the screenshot, format them for display.
            if (item.analysis) {
                analysisHTML = '<div class="ai-analysis"><h4>AI Analysis of Screenshot</h4>';
                if (item.analysis.description) {
                    analysisHTML += `<p><strong>Description:</strong> ${escapeHTML(item.analysis.description)}</p>`;
                }
                // Display diagram/chart analysis if present and not explicitly indicating absence of a diagram.
                if (item.analysis.diagramData && item.analysis.diagramData !== null && item.analysis.diagramData.contains_diagram !== false) {
                    if (item.analysis.diagramData.text_summary) { // If a text summary from AI is available.
                        analysisHTML += `<p><strong>Diagram/Chart Analysis:</strong> ${escapeHTML(item.analysis.diagramData.text_summary)}</p>`;
                    } else if (typeof item.analysis.diagramData === 'object') { // If structured data exists but no simple text summary.
                        analysisHTML += `<p><strong>Diagram/Chart Data:</strong> Structured data detected with key elements identified by AI.</p>`;
                    }
                }
                // Display layout analysis similarly.
                if (item.analysis.layout && item.analysis.layout !== null && item.analysis.layout.is_webpage_layout !== false) {
                    if (item.analysis.layout.text_summary) {
                        analysisHTML += `<p><strong>Layout Analysis:</strong> ${escapeHTML(item.analysis.layout.text_summary)}</p>`;
                    } else if (typeof item.analysis.layout === 'object') {
                        analysisHTML += `<p><strong>Layout Data:</strong> Webpage structure analyzed and key layout elements identified by AI.</p>`;
                    }
                }
                analysisHTML += '</div>';
            }
            break;

        case 'pdf': // Saved PDF document.
            const fileSizeKB = item.fileSize ? Math.round(item.fileSize / 1024) : 'Unknown';
            // For PDFs, the report shows an indicator and metadata, not the PDF content itself.
            contentHTML = `<p class="pdf-indicator">📄 PDF Document (Original file size: ${fileSizeKB}KB)</p>`;
            if (item.characterCount) { // Character count of the original page from which PDF was made.
                contentHTML += `<p><small>Original Page Approx. Character Count: ${item.characterCount.toLocaleString()}</small></p>`;
            }
            break;

        case GENERATED_ITEM_TYPE: // For AI-generated content like key points or other analyses.
            contentHTML = `<div class="content-text">${escapeHTML(item.content || 'No content available.')}</div>`;
            contentHTML += `<p><small><strong>Generated Analysis Type:</strong> ${escapeHTML(item.analysisType || 'Unknown')}</small></p>`;
            if (item.sourceTagIds) { // If it was generated from specific tags, list them.
                contentHTML += `<p><small><strong>Source Tag ID(s):</strong> ${item.sourceTagIds.join(', ')}</small></p>`;
            }
            break;

        default: // Fallback for any unknown item types.
            contentHTML = '<p><em>Unknown or unsupported content type for report display.</em></p>';
    }

    // Assemble the complete HTML block for this single item.
    return `
    <div class="item-break">ITEM #${itemNumber}</div>
    <div class="item-container">
        <div class="item-header">
            <div class="item-title">${escapeHTML(item.title || `Item ${item.id}`)}</div>
            <div class="item-meta">
                <strong>Source URL:</strong> ${item.url ? `<a href="${escapeHTML(item.url)}" target="_blank">${escapeHTML(item.url)}</a>` : 'N/A'}<br>
                <strong>Item Type:</strong> ${escapeHTML(item.type)} | <strong>Date Saved:</strong> ${itemDate}<br>
                <strong>Tags:</strong> ${tagsHTML || 'None'}
            </div>
        </div>
        <div class="content-section">
            ${contentHTML} <!-- Main content of the item -->
            ${analysisHTML} <!-- AI analysis, if any -->
        </div>
    </div>`;
}

/**
 * Generates a standardized filename for the PDF report.
 * The filename includes a prefix, a sanitized version of the tag name, and a timestamp
 * to ensure uniqueness and provide context.
 * Example: "JC-WebInsights-c2025-MyResearchTag-YYYYMMDDHHMMSS.pdf"
 *
 * @param {string} tagName - The name of the tag for which the report is generated.
 * @returns {string} The generated, sanitized filename string.
 */
function generateReportFilename(tagName) {
    const now = new Date();
    // Format timestamp as YYYYMMDDHHMMSS for inclusion in the filename.
    const timestamp = now.toISOString().slice(0, 19).replace(/[T:]/g, '').replace(/-/g, '');
    // Sanitize the tag name to make it suitable for use in a filename.
    // This replaces characters that are problematic in filenames with underscores.
    const sanitizedTag = tagName.replace(/[^a-zA-Z0-9_-]/g, '_');
    return `JC-WebInsights-c2025-${sanitizedTag}-${timestamp}.pdf`;
}

/**
 * Calculates and returns a string representing the date range of the provided content items.
 * It finds the earliest and latest `createdAt` dates among the items.
 *
 * @param {Array<object>} items - An array of content item objects, each expected to have a `createdAt`
 *                                property (parsable as a Date).
 * @returns {string} A string describing the date range (e.g., "01/01/2023 - 01/31/2023").
 *                   Returns "N/A" if items array is empty or dates are invalid.
 *                   If all items are on the same day, it returns just that date.
 */
function getDateRange(items) {
    if (!items || items.length === 0) return 'N/A'; // No items, no date range.

    // Convert `createdAt` strings to Date objects and sort them chronologically.
    const dates = items
        .map(item => new Date(item.createdAt))
        .filter(date => !isNaN(date)) // Filter out any invalid dates.
        .sort((a, b) => a - b);
    
    if (dates.length === 0) return 'N/A'; // No valid dates found.

    const earliest = dates[0];
    const latest = dates[dates.length - 1];
    
    // Format dates for display (e.g., "MM/DD/YYYY" based on locale).
    const options = { year: 'numeric', month: 'numeric', day: 'numeric' };
    const earliestStr = earliest.toLocaleDateString(undefined, options);
    const latestStr = latest.toLocaleDateString(undefined, options);

    if (earliestStr === latestStr) { // If all items are effectively on the same day.
        return earliestStr;
    } else {
        return `${earliestStr} - ${latestStr}`;
    }
}

/**
 * Escapes HTML special characters within a string to prevent XSS vulnerabilities
 * when inserting text into an HTML document. This is crucial for safely displaying
 * user-generated or web-extracted content in the PDF report.
 * Replaces '&', '<', '>', '"', and "'" with their corresponding HTML entities.
 *
 * @param {string | unknown} text - The input string to escape. If not a string, it's coerced to one.
 * @returns {string} The HTML-escaped string. Returns an empty string if the input is null or undefined
 *                   after coercion, or if the input is an object (which stringifies to [object Object]).
 */
function escapeHTML(text) {
    // Coerce to string, handle null/undefined which become "null"/"undefined"
    let str = String(text);

    // If the original input was null or undefined, String(text) yields "null" or "undefined".
    // If it was an object, it might be "[object Object]".
    // We generally want to return an empty string for these cases in an HTML context,
    // unless specific display of "null" or "undefined" is desired (which is not typical for titles/content).
    if (text === null || typeof text === 'undefined' || (typeof text === 'object' && text !== null)) {
        str = '';
    }

    return str
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;'); // Using &#039; for single quote as &apos; is not universally supported in HTML4.
}

/**
 * Generates a PDF document from a given HTML content string and initiates its download.
 * This function works by:
 * 1. Creating a data URL from the HTML content.
 * 2. Opening this data URL in a new, temporary, inactive browser tab.
 * 3. Waiting for the content to load in the temporary tab.
 * 4. Using the `generatePagePDF` utility (which leverages `chrome.debugger` or similar)
 *    to capture the content of this temporary tab as a PDF (base64 encoded).
 * 5. Closing the temporary tab.
 * 6. Converting the base64 PDF data into a data URL suitable for download.
 * 7. Using `chrome.downloads.download` to prompt the user to save the PDF file.
 *
 * @param {string} htmlContent - The complete HTML content string to be converted to PDF.
 * @param {string} filename - The desired filename for the downloaded PDF file.
 * @returns {Promise<object>} A promise that resolves to an object indicating success or failure.
 *          On success: `{ success: true, filename: string }`
 *          On failure, it throws an error which should be caught by the caller.
 * @async
 */
async function generatePDFFromHTML(htmlContent, filename) {
    try {
    try {
        // 1. Create a data URL from the HTML content. This allows loading local/dynamic HTML into a tab.
        const dataUrl = 'data:text/html;charset=utf-8,' + encodeURIComponent(htmlContent);
        
        // 2. Create a new, inactive tab to render the HTML content offscreen.
        const tab = await chrome.tabs.create({ url: dataUrl, active: false });
        
        // 3. Wait for the tab to (hopefully) finish loading its content.
        // A fixed delay is used here. For very complex HTML or slow systems, this might need adjustment
        // or a more sophisticated load detection mechanism (e.g., sending a message from the
        // loaded page back to the service worker).
        await new Promise(resolve => setTimeout(resolve, 2500)); // Increased delay slightly to 2.5 seconds.
        
        // 4. Define PDF generation options (can be customized).
        const pdfOptions = {
            landscape: false,       // Portrait orientation.
            printBackground: true,  // Crucial for including CSS background colors/images.
            scale: 0.8,             // Adjust scale to fit content better on the page (0.1 to 2.0).
            paperWidth: 8.5,        // Standard US Letter width in inches.
            paperHeight: 11,        // Standard US Letter height in inches.
            marginTop: 0.5,         // Margins in inches.
            marginRight: 0.5,
            marginBottom: 0.5,
            marginLeft: 0.5
        };
        
        // 5. Generate PDF from the tab's content using the shared `generatePagePDF` utility.
        const pdfBase64 = await generatePagePDF(tab.id, pdfOptions);
        
        // 6. Close the temporary tab as it's no longer needed.
        try { // Wrap tab removal in its own try-catch to ensure it doesn't prevent PDF download if it fails.
            await chrome.tabs.remove(tab.id);
        } catch (tabRemoveError) {
            console.warn(`[PDFReport] Could not remove temporary tab ${tab.id} after PDF generation:`, tabRemoveError);
        }
        
        if (!pdfBase64) { // Check if PDF generation was successful.
            throw new Error("PDF generation from HTML content returned empty or invalid data.");
        }
        
        // 7. Convert the base64 PDF data to a data URL suitable for download.
        const pdfDataUrl = pdfToDataUrl(pdfBase64); // Adds "data:application/pdf;base64," prefix.
        
        // 8. Initiate download of the PDF using `chrome.downloads.download`.
        await chrome.downloads.download({
            url: pdfDataUrl,
            filename: filename, // The desired filename for the downloaded file.
            saveAs: true        // Prompts the user to choose a save location.
        });
        
        console.log(`[PDFReport] PDF (generated from HTML) download initiated successfully: ${filename}`);
        return { success: true, filename: filename }; // Indicate success.
        
    } catch (error) {
        console.error('[PDFReport] Critical error during PDF generation from HTML:', error);
        // Ensure the error is propagated so the caller can handle it (e.g., by informing the user).
        throw error;
    }
}

/**
 * Initializes the local AI model (Universal Sentence Encoder by TensorFlow.js).
 * This involves loading the model. On first use, the model (~25MB) will be downloaded by the browser.
 * Checks if the AI is already initialized to prevent redundant operations.
 * @returns {Promise<object>} An object indicating success or failure, along with a message.
 * @async
 */
async function handleInitializeLocalAI() {
    try {
        console.log("[LocalAI] Initializing Universal Sentence Encoder...");
        
        // Check if localAI (from local-ai.js) is already initialized.
        if (localAI.isReady()) {
            return { success: true, message: "Local AI already initialized." };
        }

        // Call the initialization method of the localAI module.
        await localAI.initialize();
        
        console.log("[LocalAI] Initialization complete");
        return { 
            success: true, 
            message: "Local AI initialized successfully. Tag suggestions are now available." 
        };
        
    } catch (error) {
        console.error("[LocalAI] Initialization failed:", error);
        return { 
            success: false, 
            error: `Failed to initialize Local AI: ${error.message}` 
        };
    }
}

/**
 * Suggests relevant tags for a given piece of text content using the local AI model.
 * It generates an embedding for the input content and compares it (cosine similarity)
 * with pre-computed embeddings of existing tags.
 * @param {string} content - The text content for which to suggest tags.
 * @returns {Promise<object>} An object containing:
 *          - `success` (boolean): True if successful.
 *          - `payload` (Array<object>): List of suggested tags (name, score, id), if successful.
 *          - `message` (string): A user-friendly message.
 *          - `error` (string): Error message, if unsuccessful.
 * @async
 */
async function handleSuggestTags(content) {
    try {
        console.log("[LocalAI] Generating tag suggestions for content");
        
        // Ensure local AI is initialized before proceeding.
        if (!localAI.isReady()) {
            return { 
                success: false, 
                error: "Local AI not initialized. Please enable AI features first." 
            };
        }

        // Retrieve existing tags along with their stored embeddings.
        const existingTagsWithEmbeddings = await getTagsWithEmbeddings();
        
        if (existingTagsWithEmbeddings.length === 0) {
            // No existing tags to compare against, so no suggestions can be made.
            return { 
                success: true, 
                payload: [], 
                message: "No existing tags found for comparison. Add some tags first!"
            };
        }

        // Use the localAI module to get tag suggestions.
        const suggestions = await localAI.suggestTags(content, existingTagsWithEmbeddings);
        
        console.log(`[LocalAI] Generated ${suggestions.length} tag suggestions`);
        return { 
            success: true, 
            payload: suggestions, // Array of { name, score, id }
            message: `Found ${suggestions.length} suggested tags.`
        };
        
    } catch (error) {
        console.error("[LocalAI] Error suggesting tags:", error);
        return { 
            success: false, 
            error: `Failed to suggest tags: ${error.message}` 
        };
    }
}

/**
 * Generates and stores embeddings for all existing tags that do not already have one.
 * Embeddings are necessary for the local AI tag suggestion feature.
 * This function iterates through tags, generates embeddings for their names, and saves them.
 * @returns {Promise<object>} An object indicating success, counts of processed/skipped tags, or an error message.
 * @async
 */
async function handleGenerateTagEmbeddings() {
    try {
        console.log("[LocalAI] Generating embeddings for existing tags");
        
        // Ensure local AI is initialized.
        if (!localAI.isReady()) {
            return { 
                success: false, 
                error: "Local AI not initialized. Please enable AI features first." 
            };
        }

        // Get all tags from the database.
        const allTags = await getAllTags(); // From db.js
        
        if (allTags.length === 0) {
            return { 
                success: true, 
                payload: { processed: 0, skipped: 0, total: 0 },
                message: "No tags found to process." 
            };
        }

        let processed = 0; // Count of tags for which embeddings were generated.
        let skipped = 0;   // Count of tags that already had embeddings.

        // Process tags in batches to avoid overwhelming the system and to allow UI updates if needed.
        const batchSize = 10;
        for (let i = 0; i < allTags.length; i += batchSize) {
            const batch = allTags.slice(i, i + batchSize);
            
            for (const tag of batch) {
                try {
                    // Check if an embedding already exists for this tag.
                    const existingEmbedding = await getTagEmbedding(tag.id);
                    if (existingEmbedding) {
                        skipped++;
                        continue; // Skip if embedding already exists.
                    }

                    // Generate embedding for the tag name using the local AI model.
                    const embedding = await localAI.embed(tag.name);
                    
                    // Store the generated embedding.
                    await saveTagEmbedding(tag.id, embedding);
                    processed++;
                    
                    console.log(`[LocalAI] Generated embedding for tag: ${tag.name} (ID: ${tag.id})`);
                    
                } catch (error) {
                    // Log error for individual tag processing but continue with others.
                    console.error(`[LocalAI] Failed to process tag ${tag.name} (ID: ${tag.id}):`, error);
                    // Consider if this should count as skipped or a separate error count. For now, skipped.
                    skipped++;
                }
            }
            
            // Optional: Small delay between batches to yield CPU if processing is intensive.
            if (i + batchSize < allTags.length) {
                await new Promise(resolve => setTimeout(resolve, 100)); // 100ms delay.
            }
        }

        console.log(`[LocalAI] Embedding generation complete: ${processed} processed, ${skipped} skipped out of ${allTags.length} total.`);
        return { 
            success: true, 
            payload: { processed, skipped, total: allTags.length },
            message: `Tag embedding generation finished. Processed: ${processed}, Skipped (already exist): ${skipped}.`
        };
        
    } catch (error) {
        console.error("[LocalAI] Error generating tag embeddings:", error);
        return { 
            success: false, 
            error: `Failed to generate embeddings: ${error.message}` 
        };
    }
}

/**
 * Retrieves all tags along with their stored embeddings.
 * Embeddings are fetched from `chrome.storage.local`.
 * This function is used by `handleSuggestTags` to get the data needed for similarity comparisons.
 * @returns {Promise<Array<object>>} A promise that resolves to an array of tag objects,
 *          each including `id`, `name`, and `embedding` (if found).
 *          Returns an empty array if an error occurs or no tags have embeddings.
 * @async
 */
async function getTagsWithEmbeddings() {
    try {
        const allTags = await getAllTags(); // Get all tag objects (id, name) from db.js
        const tagsWithEmbeddings = [];

        for (const tag of allTags) {
            const embedding = await getTagEmbedding(tag.id); // Fetch embedding for each tag.
            if (embedding) { // Only include tags that have an embedding.
                tagsWithEmbeddings.push({
                    id: tag.id,
                    name: tag.name,
                    embedding: embedding // The actual embedding vector.
                });
            }
        }
        return tagsWithEmbeddings;
    } catch (error) {
        console.error("[LocalAI] Error getting tags with embeddings:", error);
        return []; // Return empty array on error.
    }
}

/**
 * Gets the stored embedding for a specific tag ID from `chrome.storage.local`.
 * Embeddings are stored separately (not in IndexedDB with tag metadata) primarily
 * because they can be large and `chrome.storage.local` is suitable for this.
 * @param {number} tagId - The ID of the tag.
 * @returns {Promise<Array<number>|null>} A promise that resolves to the embedding array (vector)
 *          or null if the embedding is not found or an error occurs. The promise resolves to null
 *          if `chrome.runtime.lastError` is set during the storage operation or if the key is not found.
 * @async
 */
async function getTagEmbedding(tagId) {
    try {
        const key = `tag_embedding_${tagId}`; // Define a standardized key for storing/retrieving embeddings.
        return new Promise((resolve) => {
            // Use chrome.storage.local.get to retrieve the embedding.
            chrome.storage.local.get([key], (result) => {
                if (chrome.runtime.lastError) {
                    // Log error if retrieval fails.
                    console.error(`[LocalAI] Storage error getting embedding for tag ${tagId}:`, chrome.runtime.lastError);
                    resolve(null); // Resolve with null on error.
                } else {
                    // result[key] will be the embedding if found, or undefined otherwise.
                    // Ensure to return null explicitly if undefined for consistency.
                    resolve(result[key] || null);
                }
            });
        });
    } catch (error) {
        // This catch block is primarily for synchronous errors, though most storage operations are async.
        console.error(`[LocalAI] Synchronous error in getTagEmbedding for tag ${tagId}:`, error);
        return null; // Return null on synchronous error as well.
    }
}

/**
 * Saves the embedding (a vector of numbers) for a specific tag ID into `chrome.storage.local`.
 * Embeddings are stored with a standardized key format: `tag_embedding_{tagId}`.
 *
 * @param {number} tagId - The ID of the tag for which the embedding is being saved.
 * @param {Array<number>} embedding - The embedding vector (an array of numbers) to save.
 * @returns {Promise<void>} A promise that resolves when the embedding is successfully saved.
 *          The promise rejects if an error occurs during the storage operation
 *          (e.g., if `chrome.runtime.lastError` is set).
 * @throws {Error} If a synchronous error occurs during the setup of the promise.
 * @async
 */
async function saveTagEmbedding(tagId, embedding) {
    try {
        const key = `tag_embedding_${tagId}`; // Define the key for storage.
        return new Promise((resolve, reject) => {
            // Use chrome.storage.local.set to save the embedding.
            // The object { [key]: embedding } uses a computed property name.
            chrome.storage.local.set({ [key]: embedding }, () => {
                if (chrome.runtime.lastError) {
                    // Log and reject if there's an error during saving.
                    console.error(`[LocalAI] Storage error saving embedding for tag ${tagId}:`, chrome.runtime.lastError);
                    reject(new Error(chrome.runtime.lastError.message || "Failed to save tag embedding to local storage."));
                } else {
                    resolve(); // Resolve (void) on successful save.
                }
            });
        });
    } catch (error) {
        // Handle synchronous errors, e.g., if promise setup fails.
        console.error(`[LocalAI] Synchronous error in saveTagEmbedding for tag ${tagId}:`, error);
        throw error; // Re-throw synchronous errors to be handled by the caller.
    }
}

// Final log message indicating the service worker has started, its main features, and is ready.
console.log("WebInsight Service Worker (features: Google Drive backup, PDF generation, Local AI) started and ready.");